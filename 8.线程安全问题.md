

1. 线程安全问题

![image-20201213144403921](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213144403921.png)



1. 线程安全的定义：

![image-20201213144546823](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213144546823.png)



![image-20201213144725981](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213144725981.png)



2. 线程安全的情况：

   ![image-20201213144928377](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213144928377.png)

   

3. 如何避免线程安全？什么情况出现线程安全

![image-20201213145125037](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213145125037.png)



a.运行结果错误：

```java
/**
 *  线程安全情况1： 运行结果出错
 *
 *  演示 计数不准确，找出出错的位置
 */
public class MultiThreadError implements Runnable{

    int index = 0;
    static MultiThreadError instance = new MultiThreadError();
    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(instance);
        Thread thread2 = new Thread(instance);

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println(instance.index); // 打印目前的计数结果

    }

    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            index++;
        }
    }
}
```

![image-20201213150624019](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213150624019.png)

改进查看错误位置：使用 标记数组 查看是否已经标记

```java
/**
 *  线程安全情况1： 运行结果出错
 *
 *  演示 计数不准确，找出出错的位置
 */
public class MultiThreadError implements Runnable{

    int index = 0;
    static MultiThreadError instance = new MultiThreadError();
    static AtomicInteger realIndex = new AtomicInteger();
    static AtomicInteger wrongIndex = new AtomicInteger();
    //
    static volatile CyclicBarrier cyclicBarrier1 = new CyclicBarrier(2);
    static volatile CyclicBarrier cyclicBarrier2 = new CyclicBarrier(2);


    // 用于标志是否已经被标志
    final boolean[] marked = new boolean[10000000];

    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(instance);
        Thread thread2 = new Thread(instance);

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println("表面上的运行结果：" + instance.index); // 打印目前的计数结果
        System.out.println("真正的运行结果：" + realIndex); // 打印目前的计数结果
        System.out.println("错误的运行结果：" + wrongIndex); // 打印目前的计数结果

    }

    @Override
    public void run() {
        marked[0] = true;
        for (int i = 0; i < 10000; i++) {
            try {
                cyclicBarrier2.reset();
                cyclicBarrier1.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
            index++;
            try {
                cyclicBarrier1.reset();
                cyclicBarrier2.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
            realIndex.incrementAndGet(); // 增加1

            synchronized (instance){
                if (marked[index] && marked[index - 1]){
                    System.out.println("发生错误 " + index);
                    wrongIndex.incrementAndGet();
                }
                marked[index] = true;
            }

        }
    }
}
```

b. 死锁情况 （演示）

```java
/**
 * 演示线程安全情况2： 出现死锁的情况
 */
public class MultiThreadError1 implements Runnable {

    int flag = 0;
    static Object o1 = new Object();  //作为锁资源
    static Object o2 = new Object();

    public static void main(String[] args) {

        MultiThreadError1 multiThreadError1 = new MultiThreadError1();
        MultiThreadError1 multiThreadError2 = new MultiThreadError1();

        multiThreadError1.flag = 0;
        multiThreadError2.flag = 1;

        new Thread(multiThreadError1).start();
        new Thread(multiThreadError2).start();

    }
    @Override
    public void run() {
        if (flag == 0){
            synchronized (o1){
                System.out.println("flag: " + flag);
                try {
                    Thread.sleep(1000);  //等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2){
                    System.out.println("flag: " + flag);
                }
            }

        }
        if (flag == 1){
            synchronized (o2){
                System.out.println("flag: " + flag);
                try {
                    Thread.sleep(1000);  //等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1){
                    System.out.println("flag: " + flag);
                }
            }

        }

    }
}
```

c. 对象的发布与溢出

![image-20201213162146485](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213162146485.png)

1.  返回了 原始对象的引用

```java
/**
 * 发布 与 溢出导致的问题
 */
public class MultiThreadError3 {

    private Map<String, String> statue;

    public MultiThreadError3(){
        statue = new HashMap<>();
        statue.put("1", "周一");
        statue.put("2", "周二");
        statue.put("3", "周三");
        statue.put("4", "周四");
    }
    // 出现溢出的情况
    public Map<String, String> getStatus(){
        return statue;
    }

    public static void main(String[] args) {
        MultiThreadError3 multiThreadError3 = new MultiThreadError3();
        Map<String, String> status = multiThreadError3.getStatus();

        System.out.println(status.get("1"));
        status.remove("1");
        System.out.println(status.get("1"));
    }

}
```



1.1 解决办法： 返回原始对象的 副本，避免 出现外部引用修改 内部

```java

/**
 *  1. 解决 发布 与 溢出导致的问题， 返回原始引用的 副本
 */
public class MultiThreadError3 {

    private Map<String, String> statue;

    public MultiThreadError3(){
        statue = new HashMap<>();
        statue.put("1", "周一");
        statue.put("2", "周二");
        statue.put("3", "周三");
        statue.put("4", "周四");
    }
    // 出现溢出的情况
//    public Map<String, String> getStatus(){
//        return statue;
//    }

        public Map<String, String> getStatusImproved(){
        return new HashMap<>(statue);
    }


    public static void main(String[] args) {
        MultiThreadError3 multiThreadError3 = new MultiThreadError3();

        System.out.println(multiThreadError3.getStatusImproved().get("1"));
        multiThreadError3.getStatusImproved().remove("1");
        System.out.println(multiThreadError3.getStatusImproved().get("1"));
    }

}
```

2. ```java
   
   /**
    *   初始化未完毕，就this 赋值
    */
   public class MultiThreadError4 {
       static Point point;
   
       public static void main(String[] args) throws InterruptedException {
           new PointMaker().start();
   //        Thread.sleep(10); // 时间更改， 结果不同
           Thread.sleep(105);
   
           if (point != null){
               System.out.println(point);
           }
       }
   
   
   
   }
   
   class Point{
       private final int x,y;
   
       public Point(int x, int y) throws InterruptedException {
           this.x = x;
           MultiThreadError4.point = this;
           Thread.sleep(100);
           this.y = y;
       }
   
       @Override
       public String toString() {
           return "Point{" +
                   "x=" + x +
                   ", y=" + y +
                   '}';
       }
   }
   
   class PointMaker extends Thread{
       @Override
       public void run() {
           try {
               new Point(1,1);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   }
   ```

   ```java
   /**
    * 构造函数中进行 新开线程 进行操作
    */
   public class MultiThreadError5 {
       private Map<String, String> statue;
   
       public MultiThreadError5(){
   
           // 构造函数进行 开启线程初始化
           new Thread(new Runnable() {
               @Override
               public void run() {
                   statue = new HashMap<>();
                   statue.put("1", "周一");
                   statue.put("2", "周二");
                   statue.put("3", "周三");
                   statue.put("4", "周四");
               }
           }).start();
       }
       // 出现溢出的情况
       public Map<String, String> getStatus(){
           return statue;
       }
   
       public static void main(String[] args) {
           MultiThreadError5 multiThreadError5 = new MultiThreadError5();
           Map<String, String> status = multiThreadError5.getStatus();
           System.out.println(status.get("1"));  // 出现了 空指针异常的错误  Exception in thread "main" java.lang.NullPointerException
       }
   }
   ```

总结：

![image-20201213170212956](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213170212956.png)



### 多线程的性能问题

![image-20201213170559356](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213170559356.png)



![image-20201213172518680](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213172518680.png)

![image-20201213173834015](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173834015.png)



![image-20201213173327479](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173327479.png)

![image-20201213173933205](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173933205.png)

![image-20201213173957994](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173957994.png)





![image-20201213173445933](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173445933.png)

![image-20201213173517627](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173517627.png)

![image-20201213173539133](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173539133.png)

![image-20201213173619958](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201213173619958.png)



















































































































































































































































