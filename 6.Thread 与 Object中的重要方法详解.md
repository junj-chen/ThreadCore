Thread 与 Object中的重要方法详解

### 问题？

![image-20201130204724126](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201130204724126.png)

### 1. 概览

![image-20201130204954283](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201130204954283.png)



### 3.  wait /  notify /   notify all 方法

#### 3.1 作用、用法

1. 阻塞阶段的使用

![image-20201130205511797](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201130205511797.png)



### 4.展示 wait 和 notify的基本用法

4.1 wait 方法会 释放锁资源 

```java
/**
 * 展示 wait 和 notify的基本用法， 1. 研究代码的执行顺序 2. 证明wait释放锁资源
 */
public class Wait {

    // 1. 定义object方法
    public static Object object = new Object();

    static class Thread1 extends Thread{
        @Override
        public void run() {
            // 使用synchronize进行代码块的同步
            synchronized (object){
                System.out.println(Thread.currentThread().getName() + "开始执行了");

                try {
                    object.wait();  //wait 方法会释放锁资源， 可以被中断，所以需要捕获中断异常
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("线程" + Thread.currentThread().getName() + "获得了锁");
            }
        }
    }

    static class Thread2 extends Thread{
        @Override
        public void run() {
            synchronized (object){
                // 调用同一个对象进行 唤醒 wait的线程
                object.notify();
                System.out.println("线程" + Thread.currentThread().getName() + "调用了 notify()");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {

        Thread1 thread1 = new Thread1();
        Thread2 thread2 = new Thread2();
        thread1.start();
        Thread.sleep(10);
        thread2.start();
    }
}
```

4.2 notify notifyAll

```java
/**
 *  1.  3 个线程， 线程1 和线程2 首先被阻塞，线程3唤醒他们。 notify notifyAll
 *  2.  展示 start 先执行不代表线程先启动 （由操作系统线程进行调度）
 */
public class WaitNotifyall implements Runnable{

    private static  final Object resourceA = new Object();
    @Override
    public void run() {
        synchronized (resourceA){
            System.out.println(Thread.currentThread().getName() + " 获取到了资源");


            try {
                System.out.println(Thread.currentThread().getName() + " 即将等待");
                resourceA.wait();

                System.out.println(Thread.currentThread().getName() + " 即将结束");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Runnable r = new WaitNotifyall();

        Thread threadA = new Thread(r);
        Thread threadB = new Thread(r);

        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA){
//                    resourceA.notifyAll();  //进行资源的唤醒
                    resourceA.notify();  //进行资源的唤醒
                    System.out.println("线程C 进行了唤醒");
                }
            }
        });

        threadA.start();
        threadB.start();
        Thread.sleep(200);// 注释后可以看到 先执行 start 方法不一定会优先执行
        threadC.start();

    }
}
```

4.3 只释放 monitor

```java
/**
 *  证明 wait 只释放当前的 那把锁
 */
public class WaitNotifyReleaseOwnMonitor {

    private static volatile Object resourceA = new Object();
    private static volatile Object resourceB = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA) {
                    System.out.println("ThreadA 获取到了 A锁");
                    synchronized (resourceB) {
                        System.out.println("ThreadA 获取到了 B锁");
                        try {
                            System.out.println("ThreadA 释放了 A锁");
                            resourceA.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        });

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA) {
                    System.out.println("ThreadB 获取到了 A锁");
                    System.out.println("ThreadB 尝试获取 B锁");
                    synchronized (resourceB) {
                        System.out.println("ThreadB 获取到了 B锁");
                    }
                }
            }
        });
        threadA.start();
        Thread.sleep(1000);
        threadB.start();
    }
}
```

### 5.  特点

![image-20201201212032625](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201201212032625.png)



![image-20201201212216650](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201201212216650.png)



