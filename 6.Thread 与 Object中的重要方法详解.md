Thread 与 Object中的重要方法详解

### 问题？

![image-20201130204724126](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201130204724126.png)

### 1. 概览

![image-20201130204954283](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201130204954283.png)



### 3.  wait /  notify /   notify all 方法

#### 3.1 作用、用法

1. 阻塞阶段的使用

![image-20201130205511797](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201130205511797.png)



### 4.展示 wait 和 notify的基本用法

4.1 wait 方法会 释放锁资源 

```java
/**
 * 展示 wait 和 notify的基本用法， 1. 研究代码的执行顺序 2. 证明wait释放锁资源
 */
public class Wait {

    // 1. 定义object方法
    public static Object object = new Object();

    static class Thread1 extends Thread{
        @Override
        public void run() {
            // 使用synchronize进行代码块的同步
            synchronized (object){
                System.out.println(Thread.currentThread().getName() + "开始执行了");

                try {
                    object.wait();  //wait 方法会释放锁资源， 可以被中断，所以需要捕获中断异常
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("线程" + Thread.currentThread().getName() + "获得了锁");
            }
        }
    }

    static class Thread2 extends Thread{
        @Override
        public void run() {
            synchronized (object){
                // 调用同一个对象进行 唤醒 wait的线程
                object.notify();
                System.out.println("线程" + Thread.currentThread().getName() + "调用了 notify()");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {

        Thread1 thread1 = new Thread1();
        Thread2 thread2 = new Thread2();
        thread1.start();
        Thread.sleep(10);
        thread2.start();
    }
}
```

4.2 notify notifyAll

```java
/**
 *  1.  3 个线程， 线程1 和线程2 首先被阻塞，线程3唤醒他们。 notify notifyAll
 *  2.  展示 start 先执行不代表线程先启动 （由操作系统线程进行调度）
 */
public class WaitNotifyall implements Runnable{

    private static  final Object resourceA = new Object();
    @Override
    public void run() {
        synchronized (resourceA){
            System.out.println(Thread.currentThread().getName() + " 获取到了资源");


            try {
                System.out.println(Thread.currentThread().getName() + " 即将等待");
                resourceA.wait();

                System.out.println(Thread.currentThread().getName() + " 即将结束");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Runnable r = new WaitNotifyall();

        Thread threadA = new Thread(r);
        Thread threadB = new Thread(r);

        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA){
//                    resourceA.notifyAll();  //进行资源的唤醒
                    resourceA.notify();  //进行资源的唤醒
                    System.out.println("线程C 进行了唤醒");
                }
            }
        });

        threadA.start();
        threadB.start();
        Thread.sleep(200);// 注释后可以看到 先执行 start 方法不一定会优先执行
        threadC.start();

    }
}
```

4.3 只释放 monitor

```java
/**
 *  证明 wait 只释放当前的 那把锁
 */
public class WaitNotifyReleaseOwnMonitor {

    private static volatile Object resourceA = new Object();
    private static volatile Object resourceB = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA) {
                    System.out.println("ThreadA 获取到了 A锁");
                    synchronized (resourceB) {
                        System.out.println("ThreadA 获取到了 B锁");
                        try {
                            System.out.println("ThreadA 释放了 A锁");
                            resourceA.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        });

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA) {
                    System.out.println("ThreadB 获取到了 A锁");
                    System.out.println("ThreadB 尝试获取 B锁");
                    synchronized (resourceB) {
                        System.out.println("ThreadB 获取到了 B锁");
                    }
                }
            }
        });
        threadA.start();
        Thread.sleep(1000);
        threadB.start();
    }
}
```

### 5.  特点

![image-20201201212032625](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201201212032625.png)



![image-20201201212216650](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201201212216650.png)



sleep 方法详解：

![image-20201204204142628](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201204204142628.png)

![image-20201204204207158](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201204204207158.png)

```java
/**
 * 展示 线程 sleep的时候不释放 synchronize 的 monitor， 等sleep 时间到了之后正常结束才释放锁
 */
public class SleepDontReleaseMonitor implements Runnable{
    @Override
    public void run() {
        syn();
    }
    private synchronized void syn() {
        System.out.println("线程" +Thread.currentThread().getName() + "获取到了monitor" );

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("线程" +Thread.currentThread().getName() + "释放了monitor" );
    }

    public static void main(String[] args) {
        SleepDontReleaseMonitor monitor = new SleepDontReleaseMonitor();
        new Thread(monitor).start();
        new Thread(monitor).start();
    }
}
```

```java
/**
 *  演示sleep 不释放 lock (lock 需要手动释放)
 */
public class SleepDontReleaseLock implements Runnable {

    private static final Lock lock = new ReentrantLock();



    @Override
    public void run() {
        lock.lock();
        System.out.println("线程" + Thread.currentThread().getName() + "获取到了锁");
        try {
            Thread.sleep(5000);
            System.out.println("线程" + Thread.currentThread().getName() + "解锁");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        SleepDontReleaseLock releaseLock = new SleepDontReleaseLock();

        new Thread(releaseLock).start();
        new Thread(releaseLock).start();

    }

}
```



![image-20201204205536440](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201204205536440.png)

```java
/**
 *  每隔 1 秒输出当前时间， 被中断，观察
 *  Thread.slepp()
 *  TimeUnit.SECONDS.sleep()
 *
 */
public class SleepInterrupted implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 10; i++){
            System.out.println(new Date());

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                System.out.println("被中断了");
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new SleepInterrupted());
        thread.start();

        Thread.sleep(5000);
        thread.interrupt();  // 中断
    }
}
```

sleep 总结：

![image-20201204210829594](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201204210829594.png)



![image-20201204211247622](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201204211247622.png)

join方法：

![image-20201204211440226](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201204211440226.png)



![image-20201204213840264](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201204213840264.png)





```java

**
 * 演示 join ，注意语句的输出顺序，会变化
 */
public class Join {

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "执行完毕");
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "执行完毕");
            }
        });

        thread.start();
        thread2.start();
        System.out.println("开始等待子线程运行完毕");
        thread.join();
        thread2.join();

        System.out.println("所有子线程执行完毕");
    }
}
```

```java
/**
 * 演示 join 期间被中断的效果， join 的线程一定要小心处理，要传递中断
 */
public class JoinInterrupt {
    public static void main(String[] args) {
        Thread threadMain = Thread.currentThread();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    threadMain.interrupt();  // 主线程中断
                    Thread.sleep(5000);
                    System.out.println("Thread1 finished.");
                } catch (InterruptedException e) {
                    System.out.println("子线程中断");
                }
            }
        });

        thread1.start();
        System.out.println("等待子线程运行完毕");
        try {
            thread1.join();
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + "主线程中断了");
            e.printStackTrace();
            // 将中断传递给子线程, 重要***
            thread1.interrupt();
        }

        System.out.println("子线程已运行完毕");

    }

}
```



```java
/**
 * join 加入后，主线程的状态为 waiting
 */
public class JoinThreadState {

    public static void main(String[] args) throws InterruptedException {
        Thread threadMain = Thread.currentThread();

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(3000);
                    System.out.println(threadMain.getState());// 主线程中加入 子线程后，状态 为waiting
                    System.out.println("Thread0 执行结束");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        });

        thread.start();
        System.out.println("等待子线程执行结束");
        thread.join();
        System.out.println("子线程执行完毕");

    }

}
```

实现 join方法的等价方法

```java
/**
 *  实现 join 方法的等价方法
 */
public class JoinPrinciple {
    public static void main(String[] args) throws InterruptedException {


        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                    System.out.println("Thread1 执行结束");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        });

        thread.start();
        System.out.println("等待子线程执行结束");
//        thread.join();
        // 等价于 上述的 join 方法
        synchronized (thread){
            thread.wait();// 陷入等待，但是 thread执行完毕后，会进行执行 通知方法
        }
        System.out.println("所有线程执行完毕");

    }
}
```

![image-20201207185424818](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201207185424818.png)

waiting 状态

![image-20201207185731513](C:\Users\localuser\AppData\Roaming\Typora\typora-user-images\image-20201207185731513.png)

yield 方法可以马上被 调度器进行调度





